# Лаба 03. Создание витрины данных из разных источников: файлы, NoSQL-хранилища, реляционные базы данных

## О витринах

_Витрина данных (англ. Data Mart; другие варианты перевода: хранилище данных специализированное, киоск данных, рынок данных) — срез хранилища данных, представляющий собой массив тематической, узконаправленной информации, ориентированный, например, на пользователей одной рабочей группы или департамента._ (Wikipedia)

Лабораторная предназначена для реализации на Dataframe API.

В случае проблем смотрите [Полезные советы](../FAQ.md), пункт Решение проблем.

## I. С высоты птичьего полета

У вас есть наборы данных в разных источниках:

* Cassandra – информация о клиентах: uid, пол и возраст.
* Elasticsearch – логи посещения интернет-магазина из экосистемы некоего технологического гиганта: страницы товаров, которые открывали посетители магазина, чтобы посмотреть товар или купить его.
* HDFS – информация о посещениях сторонних веб-сайтов пользователями, приобретенная у вендора: uid, набор (url, timestamp). 
* PostgreSQL - информация о тематических категориях веб-сайтов, приобретенная у вендора.

Вам надо агрегировать данные из этих источников в витрину на основе PostgreSQL для отдела маркетинга, чтобы они могли делать свой анализ и таргетировать предложения для клиентов на основе их предпочтений в сети и в магазине.

![Alt text](/images/img3.png?raw=true "Архитектура")

Адреса Cassandra, Elasticsearch, PostgreSQL находятся [здесь](../tech_info.md)

Для сохранения в PostgreSQL используйте персональную базу имя_фамилия, ваш логин имя_фамилия и пароль из личного кабинета.

## II. Описание данных

### a. Информация о клиентах

Информация о клиентах хранится в Cassandra (keyspace `labdata`, table `clients`) в следующем виде:

* `uid` – уникальный идентификатор пользователя, string
* `gender` – пол пользователя, F или M - string
* `age` – возраст пользователя в годах, integer

### b. Логи посещения интернет-магазина

*Elasticsearch index: visits*

Из бэкенда интернет-магазина приходят отфильтрованные и обогащенные сообщения о просмотрах страниц товаров и покупках. Сообщения хранятся в Elasticsearch в формате json в следующем виде:

* `uid` – уникальный идентификатор пользователя, тот же, что и в базе с информацией о клиенте (в Cassandra), либо null, если в базе пользователей нет информации об этих посетителях магазина, string
* `event_type` – buy или view, соответственно покупка или просмотр товара, string
* `category` – категория товаров в магазине, string
* `item_id` – идентификатор товара, состоящий из категории и номера товара в категории, string
* `item_price` – цена товара, integer
* `timestamp` – unix epoch timestamp в миллисекундах

### c. Логи посещения веб-сайтов

`hdfs:///labs/laba03/weblogs.json`

Логи хранятся в формате json на HDFS и имеют следующую структуру:

* `uid` – уникальный идентификатор пользователя, тот же, что и в базе с информацией о клиенте (в Cassandra),
* массив `visits` c некоторым числом пар (timestamp, url), где `timestamp` – unix epoch timestamp в миллисекундах, `url` - строка.

В этом датасете не все записи содержат `uid`. Это означает, что были покупатели, еще пока не идентифицированные и не внесенные в базу данных клиентов. Покупки и просмотры таких покупателей можно игнорировать в этом задании.

### d. Информация о категориях веб-сайтов

Эта информация хранится в базе данных PostgreSQL `labdata` таблице `domain_cats`:

* `domain` (только второго уровня), string
* `category`, string 

Используйте ваш логин (нужно заменить в логине "." на "_") и пароль от ЛК для соединения с PostgreSQL.

## III. Задание 

Ознакомьтесь с памяткой по [PostgreSQL](../PostgreSQL.md).

Используя psql, создайте в вашей базе данных `имя_фамилия` таблицу `clients`  со следующими колонками:

uid, gender, age_cat, shop_cat1, ... , shop_catN, web_cat1, ... , web_catN

где:
* `uid` (primary key) – uid пользователя.
* `gender` – пол пользователя: `M`, `F`.
* `age_cat` – категория возраста, одна из пяти: `18-24`, `25-34`, `35-44`, `45-54`, `>=55`.
* `shop_cat`, `web_cat` – категории товаров и категории веб-сайтов.

Дайте пользователю `labchecker2` привилегию на `SELECT` из этой таблицы.
> При использовании overwrite при записи в таблицу Postgres, нужно давать гранты на чтение таблицы каждый раз после пересоздания таблицы.

Внимание! 

* Категории товаров берутся из логов посещения интернет-магазина. Чтобы сделать из категорий названия колонок, обратите внимание на метод pivot. Названия категорий приводятся к нижнему регистру, пробелы или тире заменяются на подчеркивание, к категории прибавляется приставка `shop_`. Например  `shop_everyday_jewelry`.

* Категории веб-сайтов берутся из датасета категорий вебсайтов, и точно также из них создаются имена колонок. Например: `web_arts_and_entertainment`.
* После вычленения домена из URL нужно удалить из доменов "www."

В колонках категорий товаров должно быть число посещений соответствующих страниц, а в колонках категорий веб-сайтов - число посещений соответствующих веб-сайтов.

Как оформить лабораторную смотрите ниже.

В случае проблем смотрите [Полезные советы](../FAQ.md), пункт Решение проблем.

## IV. Оформление работы

Начиная с этой лабораторной и для всех последующих лабораторных, выкладывать их в репозиторий курса и делать pull-request больше не надо.

Оформите решение в виде [Spark проекта](../idea.md).

Начиная с этой лабораторной и для всех последующих лабораторных, выкладывайте проект для проверки чекером в новый репозиторий: [Работа с приватным Git репозиторием](../Github_Repo.md).

Проект должен компилироваться и запускаться следующим образом:

```
cd lab03/data_mart
sbt package
spark-submit --packages org.elasticsearch:elasticsearch-spark-20_2.11:версия_Elastichsearch,com.datastax.spark:spark-cassandra-connector_2.11:версия_Cassandra,org.postgresql:postgresql:версия_библиотеки_PostgreSQL --class data_mart target/scala-2.11/data_mart_2.11-1.0.jar 
```

Версии можно узнать [здесь](../tech_info.md).

В случае проблем смотрите [Полезные советы](../FAQ.md), пункт Решение проблем.

## V. Проверка

Чекер проверит:
* наличие файла с решением в репо, наличие .gitignore и его содержимое,
* наличие и структуру таблицы,
* число строк (пользователей) в таблице,
* число пользователей в каждой возрастной категории,
* некоторые записи, сравнив их с эталонными.

В случае проблем смотрите [Полезные советы](../FAQ.md), пункт Решение проблем.
