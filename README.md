Создание витрины данных из разных источников: файлы, NoSQL-хранилища, реляционные базы данных

## I. С высоты птичьего полета

Есть наборы данных в разных источниках:

* Cassandra – информация о клиентах: uid, пол и возраст.
* Elasticsearch – логи посещения интернет-магазина из экосистемы некоего технологического гиганта: страницы товаров, которые открывали посетители магазина, чтобы посмотреть товар или купить его.
* HDFS – информация о посещениях сторонних веб-сайтов пользователями, приобретенная у вендора: uid, набор (url, timestamp). 
* PostgreSQL - информация о тематических категориях веб-сайтов, приобретенная у вендора.

Надо агрегировать данные из этих источников в витрину на основе PostgreSQL для отдела маркетинга, чтобы они могли делать свой анализ и таргетировать предложения для клиентов на основе их предпочтений в сети и в магазине.

![Alt text](/images/img3.png?raw=true "Архитектура")

Адреса Cassandra, Elasticsearch, PostgreSQL находятся [здесь](../tech_info.md)

Для сохранения в PostgreSQL используйте персональную базу имя_фамилия, ваш логин имя_фамилия и пароль из личного кабинета.

## II. Этапы проекта

* filter - Сохранение логов из Kafka в Spark по расписанию, с фильтрацией датасета по признаку. Описание ниже.
* users_items - Подготовка матрицы users x items по логам из Kafka для прогнозирования пола и возраста.
* features - Подготовка матрицы признаков по логам, лежащим на HDFS, для модели машинного обучения
* mlproject - Обучение модели, инференс модели в real-time
* dashboard - Мониторинг качества работы модели машинного обучения.


## III. Описание данных

### a. Информация о клиентах

Информация о клиентах хранится в Cassandra (keyspace `labdata`, table `clients`) в следующем виде:

* `uid` – уникальный идентификатор пользователя, string
* `gender` – пол пользователя, F или M - string
* `age` – возраст пользователя в годах, integer

### b. Логи посещения интернет-магазина

*Elasticsearch index: visits*

Из бэкенда интернет-магазина приходят отфильтрованные и обогащенные сообщения о просмотрах страниц товаров и покупках. Сообщения хранятся в Elasticsearch в формате json в следующем виде:

* `uid` – уникальный идентификатор пользователя, тот же, что и в базе с информацией о клиенте (в Cassandra), либо null, если в базе пользователей нет информации об этих посетителях магазина, string
* `event_type` – buy или view, соответственно покупка или просмотр товара, string
* `category` – категория товаров в магазине, string
* `item_id` – идентификатор товара, состоящий из категории и номера товара в категории, string
* `item_price` – цена товара, integer
* `timestamp` – unix epoch timestamp в миллисекундах

### c. Логи посещения веб-сайтов

`hdfs:///labs/laba03/weblogs.json`

Логи хранятся в формате json на HDFS и имеют следующую структуру:

* `uid` – уникальный идентификатор пользователя, тот же, что и в базе с информацией о клиенте (в Cassandra),
* массив `visits` c некоторым числом пар (timestamp, url), где `timestamp` – unix epoch timestamp в миллисекундах, `url` - строка.

В этом датасете не все записи содержат `uid`. Это означает, что были покупатели, еще пока не идентифицированные и не внесенные в базу данных клиентов. Покупки и просмотры таких покупателей можно игнорировать в этом задании.

### d. Информация о категориях веб-сайтов

Эта информация хранится в базе данных PostgreSQL `labdata` таблице `domain_cats`:

* `domain` (только второго уровня), string
* `category`, string 

Используйте ваш логин (нужно заменить в логине "." на "_") и пароль от ЛК для соединения с PostgreSQL.

## III. Задание 

Ознакомьтесь с памяткой по [PostgreSQL](../PostgreSQL.md).

Используя psql, создайте в вашей базе данных `имя_фамилия` таблицу `clients`  со следующими колонками:

uid, gender, age_cat, shop_cat1, ... , shop_catN, web_cat1, ... , web_catN

где:
* `uid` (primary key) – uid пользователя.
* `gender` – пол пользователя: `M`, `F`.
* `age_cat` – категория возраста, одна из пяти: `18-24`, `25-34`, `35-44`, `45-54`, `>=55`.
* `shop_cat`, `web_cat` – категории товаров и категории веб-сайтов.

Дайте пользователю `labchecker2` привилегию на `SELECT` из этой таблицы.
> При использовании overwrite при записи в таблицу Postgres, нужно давать гранты на чтение таблицы каждый раз после пересоздания таблицы.

Внимание! 

* Категории товаров берутся из логов посещения интернет-магазина. Чтобы сделать из категорий названия колонок, обратите внимание на метод pivot. Названия категорий приводятся к нижнему регистру, пробелы или тире заменяются на подчеркивание, к категории прибавляется приставка `shop_`. Например  `shop_everyday_jewelry`.

* Категории веб-сайтов берутся из датасета категорий вебсайтов, и точно также из них создаются имена колонок. Например: `web_arts_and_entertainment`.
* После вычленения домена из URL нужно удалить из доменов "www."

В колонках категорий товаров должно быть число посещений соответствующих страниц, а в колонках категорий веб-сайтов - число посещений соответствующих веб-сайтов.

Как оформить лабораторную смотрите ниже.

В случае проблем смотрите [Полезные советы](../FAQ.md), пункт Решение проблем.
